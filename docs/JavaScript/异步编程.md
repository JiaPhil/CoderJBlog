# JavaScript 的异步编程

## 同步模式和异步模式

### 同步模式
1. 调用代码都是依次按顺序进入call stack（调用栈）执行；
2. 执行完后弹出call stack,然后执行后面代码；

### 异步模式
1. 将异步调用的代码，放入异步调用线程，call stack主线程的任务继续执行；
2. 在异步调用线程中执行异步函数，再进入消息队列；
3. 等待当前主线程的同步任务执行完毕，进入主线程执行；
```js
const promise = new Promise(function (resolve, reject) {
  resolve(100) //成功

  // reject(new Error('promise error')) // 失败
})

// 进入主线程执行
console.log('begin')


// 进入消息队列,等待同步任务执行完毕
promise.then(function (res) {
  console.log(res)
}, function (err) {
  console.log(err)
})

// 进入主线程
console.log('end')

/**
 * begin
 * end
 * 100
 */
```

![async](/images/async.png)

### 回调函数（所有异步编程方案的根基）
* 调用者定义 交给执行者执行的函数叫做回调函数
* 回调函数是作为参数传递给另一个函数并在其父函数完成后执行的函数。

## Promise 
* promise的本质 就是 使用回调函数定义异步任务结束后所需要执行的任务
* Promise的嵌套是最大的误区，最好的方法是使用Promise的链式调用
```js
// Promise 构造Ajax
function ajax(url) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET',url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if(this.status === 200) {
        resolve(this.response)
      }else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
```