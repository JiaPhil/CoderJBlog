# 函数式编程

## 前言

函数式编程的特性
* [纯函数](#纯函数pure-funtions)
* [函数柯里化](#函数柯里化haskell-brooks-curry)
* [函数组合](#函数组合)

```tex
函数式编程编程库lodash

函数式编程事对运算过程进行抽象
面向对象编程是对现实世界上的事物进行抽象

函数式编程 值的是数学中的函数即映射关系

相同输入始终要得到相同的输出（纯函数）
函数式编程 用来描述数据(函数)之间的映射
```

### 函数式
- 用函数写程序
- 实现最小粒度的函数封装、组合、复用（柯里化）
- 更换思维方式：用表达式来描述程序
- 递归是常用手段
- 函数没有副作用（输入对输出映射 没对其他进行操作）


### 高阶函数

- 可以把函数作为**参数**传递给另一个函数
- 可以把函数另一个函数的**返回值**

```ts
// 函数作为返回值
function makeFn(){
  return function (){
    console.log('hello Fn')
  }
}

function once(fn) {
  let done = false
  return function () {
    if(!done){
      done = true 
      // this 指向的是function() 匿名函数
      return fn.apply(this, arguments)
    }
  }
}

const pay = once(function (money){
  console.log('ddd')
})

pay(5)
```

- 高阶函数：屏蔽细节，只需关注目标，抽象通用的函数

### 常用高阶函数
- map
- every
- some

```ts
// 实现map函数
const map = (array: Array<string>, fn: Function) => {
  let results = []
  for(let value of array){
    results.push(fn(value))
  }
  return results
}

// 实现every函数: 判断数组中每一个元素是否都满足条件
const every = (array: Array<any>, fn: Function) => {
  let results = false;
  for (let value of array) {
    results = fn(value);
    if (!results) {
      break;
    }
  }
  return results;
};

// 实现some函数: 判断数组中是否有一个元素满足条件
const some = (array: Array<any>, fn: Function) => {
  let results = false;
  for (let value of array) {
    results = fn(value);
    if (results) {
      break;
    }
  }
  return results;
};
``` 


## 闭包(Closure)

1. 闭包: 函数和其周围的状态的引用捆绑在一起形成闭包
2. **概念**：可以在另一个作用域 调用一个函数的内部函数并访问到外部函数的作用域的成员
3. (函数作为另一个函数的返回值)
4. **作用**：延长外部函数作用域成员的作用范围

```ts
function makeFn() {
  let meg = 'Hello World'
  return function () {
    console.log(msg)
  }
}
// makeFn从执行栈上移除，但msg被外部函数引用不能释放
let f = makeFn()
```

- 闭包的本质：函数在执行的时候会放到一个执行栈上 当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员被外部引用不能释放，因此内部函数依旧可以访问外部函数成员


## 纯函数(Pure funtions)
### 纯函数概念
- 必须要参数和返回值
- 相同的输入永远会得到相同的输出,不会有任何副作用(不会改变原数据)
- 细分为可复用的小函数，只专注输入输出并相同的输入永远会得到相同的输出
- 🚩loadash:  https://www.lodashjs.com/

```ts
function gerSum(n1, n2){
  return n1 + n2
}
```
- 函数式编程不会保留中间的计算结果，所以变量式不可变的（无状态的）

### 纯函数的好处

* 可缓存，提高性能 _.memoize()
* 可测试
* 并行处理



```ts
// 模拟memoize
function memoize(fn:Function){
 let cache = {}
 return function () {
    const key = JSON.stringify(arguments)
    cache[key] = cache[key] || fn.apply(f, arguments)
    return cache[key]
 }
}
```

### 副作用
```ts
// 不纯的 （受外部条件影响）
let mini = 18 
function checkAge (age: number): boolean {
   return age >= mini 
}
// 纯的(有硬编码，后续可以通过柯里化解决) 
function checkAge (age: number): boolean {
   let mini = 18 
   return age >= mini 
}
```
副作用是让一个函数变得不纯会降低一个函数的复用性和可扩展性，如果函数依赖于外部状态就无法保证输出相同，就会带来副作用。

副作用来源
* 全局变量
* 配置文件
* 数据库
* 获取用户输入
* ......


## 函数柯里化(Haskell Brooks Curry)

* 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变） 
* 然后返回一个新的函数接收剩余的参数，返回结果

```ts
// 去除上例硬编码
funtion checkAge(min: number) {
  return function (age: number) {
    return age >= min
  }
}

// ES6
let checkAge = min => (age => age >= min)
```

### loadash的柯里化
* _.curry(func)
  * 功能: 创建一个函数，该函数接收一个或多个func的参数，如果func所需要的参数都被提供则直接执行func并返回结果。否则继续返回该函数并等待接收剩余参数
  * 参数: 需要柯里化的函数，纯函数
  * 返回值: 柯里化后的函数

### 柯里化案例

```ts
// 匹配空白字符
const _ = required('loadash')

const match = _.curry(function (reg, str) {
  return str.match(reg)
})

const haveSpace = match(/\s+/g)
console.log(haveSpace('hello world'))

// filter
const filter = _.curry(function (func, array) {
  return array.filter(func)
})

const findSpace = filter(haveSpace)
console.log(findSpace(['John Son', 'John_Donne']))
```
* _.curry参数是一个func并返回一个函数，若提供全部参数 则返回该func的返回值，若没有提供全部参数，curry继续返回该func并等待接受剩余参数

### 实现原理
* func作为参数
* 调用形式
  * 形参 == 实参 直接调用func
  * 形参 > 实参 返回一个函数 并等待接受剩余参数

```ts
function curry (func: Function) {
  return function curriedFn(...args) {
    // 实参长度大于形参长度
    if(args.length < func.length){
      // 返回一个函数并等待接收参数
      return function () {
        return curriedFn(...args.concat(Array.from(arguments)))
      }
    }
    return func(...args)
  }
}
```

### 总结
* 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数（闭包）
* 这是一种对函数参数的'缓存'（闭包）
* 让函数变的更灵活，让函数的粒度更小
* 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能


## 函数组合

